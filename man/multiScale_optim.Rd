% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiScale_optim.R
\name{multiScale_optim}
\alias{multiScale_optim}
\title{Multiscale optimization}
\usage{
multiScale_optim(fitted_mod,
                 kernel_inputs,
                 method ='L-BFGS-B',
                 par = NULL,
                 opt_parallel = FALSE,
                 n_cores = NULL)
}
\arguments{
\item{fitted_mod}{Model object of class glm, lm, gls, or unmarked}

\item{kernel_inputs}{Object created from running \code{\link[multiScaleR]{kernel_prep}}}

\item{method}{Optimizer to be used. Default: 'L-BFGS-B', which is the only optimization method supported by \code{\link[optimParallel]{optimParallel}}}

\item{par}{Optional starting values for parameter estimation. If provided, must be scaled by the `unit_conv` used during `kernel_prep` (which defaults to 1e5 if not specified), Default: NULL}

\item{n_cores}{If attempting to optimize in parallel, the number of cores to use. Default: NULL}
}
\value{
Returns a list of class `multiScaleR` containing scale estimates, shape estimates (if using kernel = 'expow'), optimization results, and the final optimized model.
}
\description{
Function to conduct multiscale optimization
}
\details{
Identifies the kernel scale, and uncertainty of that scale, for each raster within the context of the fitted model provided.
}
\examples{
## NOT RUN
pts <- vect(cbind(c(3,5,7),
                  c(7,5,3)))

mat_list <- list(r1 = rast(matrix(rnorm(100),
                                  nrow = 10)),
                 r2 = rast(matrix(rnorm(100),
                                  nrow = 10)))
rast_stack <- rast(mat_list)
kernel_inputs <- kernel_prep(pts = pts,
                             raster_stack = rast_stack,
                             max_D = 2,
                             kernel = 'gaussian',
                             sigma = NULL)
## Example response data
y <- rnorm(3)

## Create data frame with raster variables
df <- data.frame(y = y,
                 kernel_inputs$kernel_dat)
mod <- glm(y ~ r1 + r2,
           data = df)

## NOTE: This code is only for demonstration
## Optimization results will have no meaning
opt <- multiScale_optim(fitted_mod = mod,
                        kernel_inputs = kernel_inputs,
                        method ='L-BFGS-B',
                        par = NULL,
                        opt_parallel = FALSE,
                        n_cores = NULL)

}
\seealso{
\code{\link[optimParallel]{optimParallel}}
}
