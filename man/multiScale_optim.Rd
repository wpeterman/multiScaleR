% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiScale_optim.R
\name{multiScale_optim}
\alias{multiScale_optim}
\title{Multiscale optimization}
\usage{
multiScale_optim(fitted_mod,
                 kernel_inputs,
                 method ='L-BFGS-B',
                 par = NULL,
                 opt_parallel = FALSE,
                 n_cores = NULL)
}
\arguments{
\item{fitted_mod}{Model object of class glm, lm, gls, or unmarked}

\item{kernel_inputs}{Object created from running \code{\link[multiScaleR]{kernel_prep}}}

\item{method}{Optimizer to be used. Default: 'L-BFGS-B', which is the only optimization method supported by \code{\link[optimParallel]{optimParallel}}}

\item{par}{Optional starting values for parameter estimation. If provided, should be divided by the `max_D` value to be appropriately scaled. Default: NULL}

\item{n_cores}{If attempting to optimize in parallel, the number of cores to use. Default: NULL}
}
\value{
Returns a list of class `multiScaleR` containing scale estimates, shape estimates (if using kernel = 'expow'), optimization results, and the final optimized model.
}
\description{
Function to conduct multiscale optimization
}
\details{
Identifies the kernel scale, and uncertainty of that scale, for each raster within the context of the fitted model provided.
}
\examples{
## NOT RUN
pts <- vect(cbind(c(3,5,7),
                  c(7,5,3)))

mat_list <- list(r1 = rast(matrix(rnorm(100),
                                  nrow = 10)),
                 r2 = rast(matrix(rnorm(100),
                                  nrow = 10)))
rast_stack <- rast(mat_list)
kernel_inputs <- kernel_prep(pts = pts,
                             raster_stack = rast_stack,
                             max_D = 2,
                             kernel = 'gaussian',
                             sigma = NULL)
## Example response data
y <- rnorm(3)

## Create data frame with raster variables
df <- data.frame(y = y,
                 kernel_inputs$kernel_dat)
mod <- glm(y ~ r1 + r2,
           data = df)

## NOTE: This code is only for demonstration
## Optimization results will have no meaning

opt <- multiScale_optim(fitted_mod = mod,
                        kernel_inputs = kernel_inputs,
                        method ='L-BFGS-B',
                        par = NULL,
                        opt_parallel = FALSE,
                        n_cores = NULL)

## Using package data
data('pts')
data('count_data')
hab <- terra::rast(system.file('data/hab.tif', package = 'multiScaleR'))

kernel_inputs <- kernel_prep(pts = pts,
                             raster_stack = hab,
                             max_D = 250,
                             kernel = 'gaussian')

mod <- glm(y ~ hab,
           family = poisson,
           data = count_data)

## Optimize scale
opt <- multiScale_optim(fitted_mod = mod,
                        kernel_inputs = kernel_inputs,
                        opt_parallel = FALSE)

## Summary of fitted model
summary(opt)

## 'True' parameter values data were simulated from:
# hab scale = 75
# Intercept = 0.5,
# hab slope estimate = 0.75

## Plot and visualize kernel density
plot(opt)


## Apply optimized kernel to the environmental raster
opt_hab <- kernel_scale.raster(hab, scale_opt = opt)

plot(c(hab, opt_hab))

}
\seealso{
\code{\link[kernel_dist]{kernel_dist}}

\code{\link[optimParallel]{optimParallel}}
}
